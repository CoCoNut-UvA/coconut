
start phase startPhase {
    info = "The starting point"
    prefix = RT

    actions {
        pass scanAndParse;
        semantic;
        dynamic_backend;
        phase_driver;
        gen_dot;
        print;
    }
};

phase semantic {
    info = "Main part"
    prefix = SEA

    actions {
        buildSymbolTable;
        checkExistance;
        unwrapSetExpr;
        reachability;
    }
};


phase phase_driver {
    info = "Generate the missing parts of the phase driver"

    actions {
        gen_action_array_header;
        gen_ids_tables;
        gen_action_array;
    }
};

phase dynamic_backend {
    info = "Generating part for the dynamic backend"
    prefix = DDB

    actions {
        dynamic_gen_ast;
        pass dynamic_start_enum_header;
        dynamic_genEnum;
        dynamic_genEnumValues;
        dynamic_gen_trav_data;
        pass dynamic_start_table_gen;
        dynamic_genTravVtable;
        dynamic_genPassTable;
        dynamic_genSystemTraversals;
        dynamic_genTravTable;
        dynamic_genTravDataTables;
        dynamic_genActionsHeader;
        dynamic_genCopyTraversal;
        dynamic_genFreeTraversal;
        dynamic_genCheckTraversal;
    }
};

phase dynamic_gen_trav_data {
    info = "Generate the trav data requirements."
    prefix = DGTD

    actions {
        pass dynamic_start_trav_data;
        dynamic_genTravDataStructs;
        dynamic_genTravDataUnion;
        dynamic_genTravDataGetters;
        dynamic_genTravDataCtorsHeader;
        pass dynamic_switch_trav_data;
        dynamic_genTravDataCtors;
    }
};

phase dynamic_gen_ast {
    info = "Generate the required files for managing user nodes and AST manipulation"
    prefix = DGA

    actions {
        pass dynamic_start_ast_header;
        dynamic_genNodeStructs;
        dynamic_genNodeMacros;
        dynamic_genNodeInitFunctions;
        dynamic_genNodeUnion;
        pass dynamic_genBaseNode;
        pass dynamic_switch_to_ast_source;
        pass dynamic_genBaseNodeInit;
        dynamic_genNodeConstructor;
    }
};

traversal gen_dot {
    info = "Generate a dot diagram of the AST."
    prefix = GD

    nodes = {inode, child, ast, inodeset, setliteral}
};

traversal dynamic_genTravDataTables {
    prefix = DGTDT
    nodes = {ast, itraversal}

    travdata = {
        unsafe fileptr file,
        int in_init_round,
        int indent
    }
};


traversal gen_ids_tables {
    prefix = GIT

    nodes = {
        ast, iphase, iactions
    }
};

traversal gen_action_array_header {
    prefix = GAAH

    nodes = action | {ast}
};

traversal gen_action_array {
    prefix = GAA

    nodes = action | {ast}
};

traversal dynamic_genTravDataUnion {
    prefix = DGTDU
    nodes = {ast, itraversal}
};

traversal dynamic_genTravDataGetters {
    prefix = DGTDG
    nodes = {itraversal}
};

traversal dynamic_genTravDataCtorsHeader {
    prefix = DGTDCH
    nodes = {itraversal}
};

traversal dynamic_genTravDataCtors {
    prefix = DGTDC
    nodes = {itraversal, itravdata}
};

traversal dynamic_genTravDataStructs {
    prefix = DGTDS
    nodes = {itraversal, itravdata}
};

traversal dynamic_genCheckTraversal {
    prefix = DGCHT
};


traversal dynamic_genFreeTraversal {
    prefix = DGFT
};

traversal dynamic_genConstructorCall {
    prefix = DGCC

    nodes = {ast, inode, child, attribute}
};

traversal dynamic_genCopyTraversal {
    prefix = DGCT
};

traversal dynamic_genTravActions {
    prefix = DGTA

    nodes = {ast, inode}
};

traversal dynamic_genActionsHeader {
    prefix = DGAH

    nodes = {itraversal, ipass, ast, inode, setliteral, id}
};

traversal dynamic_genSystemTraversals {
    prefix = DGST

    nodes = {ast, inode}
};

traversal dynamic_genTravTable {
    prefix = DGTT

    nodes = {ast, itraversal}
};

traversal dynamic_genPassTable {
    prefix = DGPT

    nodes = {ast, ipass}
};

traversal dynamic_genNodesForTravTable {
    prefix = DGNFTT

    nodes = {ast, inode}
};

traversal dynamic_genTravVtable {
    prefix = DGTV

    nodes = {itraversal, ast}
};

traversal dynamic_genEnumValues {
    prefix = DGEV

    nodes = {ienum, ast, id}
};

traversal dynamic_genEnum {
    prefix = DGE

    nodes = {ast, inode, itraversal, inodeset, ipass}
};

traversal dynamic_genNodeConstructor {
    prefix = DGNC
    nodes = {ast, inode, child, attribute}
};

traversal dynamic_genNodeUnion {
    prefix = DGBU

    nodes = {ast, inode}
};

traversal dynamic_genNodeInitFunctions {
    prefix = DGIF

    nodes = {ast, inode, child, attribute}
};


traversal dynamic_genNodeStructs {
    prefix = DGNS

    nodes = {ast, inode, child, attribute}
};

traversal dynamic_genNodeMacros {
    prefix = DGNM

    nodes = {ast, inode, child, attribute}
};


traversal checkExistance {
    prefix = CEX
};

traversal buildSymbolTable {
    prefix = BST
};

traversal unwrapSetExpr {
    prefix = USE
    nodes = setexpr | {ast}
};

traversal reachability {
    prefix = RCB

    nodes = {
        ast, setliteral, itraversal, inode, child, inodeset
    }
};

traversal print {
    info = "Print the ast"
    prefix = PRT
};


root node ast {
    children {
        iphase iphases;
        itraversal itraversals;
        ipass ipasses;
        inode inodes;
        inodeset inodesets;
        ienum enums;
        ste stable;
    }
    attributes {
        int num_traversals;
        int num_nodes;
        inode root_node;
        iphase start_phase;
    }
};

nodeset action = { iphase, itraversal, ipass};
nodeset link = action | {inode};

node iactions {
    children {
        iactions next;
    }
    attributes {
        id reference;
    }
};

node iphase {
    children {
        iactions iactions;
        iphase next;
    }
    attributes {
        id name { constructor };
        int is_start { constructor };
        int is_cycle;
        string iinfo;
        id iprefix;
        id gate_func;
    }
};

node itraversal {
    children {
        setexpr inodes;
        itravdata data;
        itraversal next;
    }
    attributes {
        int index;
        id name { constructor };
        string iinfo;
        id iprefix;

    }
};

node ipass {
    children {
        ipass next;
    }
    attributes {
        id name { constructor };
        string iifno { constructor };
        id iprefix { constructor };
        id target_func;
    }
};

node inode {
    children {
        id name { constructor };
        inode next;
        child ichildren;
        attribute iattributes;
    }

    attributes {
        string iifno { constructor };
        int is_root;
        int index;
    }
};

node inodeset {
    children {
        id name;
        setexpr expr;
        id unpacked;
        inodeset next;
    }
    attributes {
        string iinfo;
    }
};

enum child_type {
    prefix = CT
    values = {
        inode, inodeset
    }
};

node child {
    children {
        id name { constructor };
        id type_reference;
        child next;
    }

    attributes {
        child_type type;
        int in_constructor;
        int is_mandatory;
    }
};

node ste {
    children {
        ste next;
    }
    attributes {
        id key;
        link value;
    }
};

enum attribute_type {
    prefix = AT
    values = {
        user, link, link_or_enum, int, string, bool, int8, int16, int32, float, double, uint, uint8, uint16, uint32
    }
};

enum setoperation_type {
    prefix = SO
    values = {
        iunion, intersect, difference
    }
};

node setreference {
    children {
        id reference;
    }
};

node setliteral {
    children {
        id reference;
        setliteral next;
    }
};

node setoperation {
    children {
        setexpr left {constructor};
        setexpr right {constructor};
    }
    attributes {
        setoperation_type type { constructor };
    }
};

nodeset setexpr = {setoperation, setreference, setliteral};

node itravdata {
    children {
        id name { constructor };
        id type_reference;
        itravdata next;
    }

    attributes {
        attribute_type type;
        string include_file; 
    }
};

node attribute {
    children {
        id name;
        id type_reference;
        attribute next;
    }
    attributes {
        attribute_type type; 
        int in_constructor;
    }
};

node ienum {
    children {
        id vals {constructor};
        id name {constructor};
        id iprefix {constructor};
        ienum next;
    }
    attributes {
        string iinfo { constructor };
    }
};

node id {
    children {
        id next;
    }
    attributes {
        string orig { constructor };
        string lwr { constructor };
        string upr { constructor };
        int row;
        int col_begin;
        int col_end;
    }
};
